// Generated by CoffeeScript 1.3.3
(function() {
  var Orange, fileError, findPeaksForSet, openAndReadFile, openAndWriteFile, openFile, readFile, smooth, writeFile;

  Orange = require('orange');

  window.URL = window.URL || window.webkitURL;

  window.requestAnimationFrame = window.webkitRequestAnimationFrame;

  window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;

  navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia;

  $(function() {
    var $button, $canvas, HEIGHT, WIDTH, averageDistance, capture, captureDuration, ctx, error, intensities, localMediaStream, render, set, showVideoStream, startTime, timestamps, video, _ref;
    _ref = [640, 480], WIDTH = _ref[0], HEIGHT = _ref[1];
    video = $('video').get(0);
    $canvas = $('canvas');
    $button = $('button');
    ctx = $canvas.get(0).getContext('2d');
    localMediaStream = null;
    startTime = null;
    intensities = [];
    timestamps = [];
    captureDuration = 10000;
    set = new Orange.JobSet;
    set.on('complete', function(jobs) {
      var job, points, write, _i, _len;
      console.log("Processing frames complete.");
      points = [];
      for (_i = 0, _len = jobs.length; _i < _len; _i++) {
        job = jobs[_i];
        points.push([job.data.timestamp, job.data.calculated.intensity]);
      }
      write = openAndWriteFile('series.json', JSON.stringify(points));
      window.requestFileSystem(window.TEMPORARY, 1024 * 1024, write, fileError);
      return render(points);
    });
    capture = function() {
      var job, now, pixels, timestamp;
      if (startTime == null) {
        $('#counter').css('color', 'green').countdown(captureDuration);
      }
      now = (new Date).getTime();
      if (startTime == null) {
        startTime = now;
      }
      timestamp = now - startTime;
      if (localMediaStream) {
        ctx.drawImage(video, 0, 0);
      }
      pixels = ctx.getImageData(0, 0, WIDTH, HEIGHT);
      job = new Orange.Job('calculate_intensity', {
        pixels: pixels.data,
        timestamp: timestamp
      });
      set.push(job);
      if (timestamp < captureDuration) {
        return requestAnimationFrame(capture);
      } else {
        return set.perform();
      }
    };
    showVideoStream = function(stream) {
      video.src = window.URL.createObjectURL(stream);
      localMediaStream = stream;
      return $('#counter').countdown(5000, capture);
    };
    error = function() {
      return console.error(arguments);
    };
    $('#capture').on('click', function() {
      return navigator.getUserMedia({
        video: true
      }, showVideoStream, error);
    });
    $('#render').on('click', function() {
      var callback, read;
      callback = function(content) {
        var chart, indexed, maxPeaks, mean, meanDurationMax, meanDurationMin, minPeaks, peak, points, smoothed, sum, values, _i, _j, _len, _len1, _results;
        points = JSON.parse(content);
        timestamps = _.map(points, function(point) {
          return point[0];
        });
        values = _.map(points, function(point) {
          return point[1];
        });
        sum = _.reduce(values, (function(memo, value) {
          return memo + value;
        }), 0);
        mean = sum / values.length;
        indexed = _.map(values, function(value, index) {
          return [index, value];
        });
        smoothed = smooth(indexed, 4, 5, (function(e) {
          return e[1];
        }), (function(s, e) {
          return [e[0], s];
        }));
        minPeaks = findPeaksForSet(indexed, 3, 3.5, (function(e) {
          return e[1];
        }), (function(e) {
          return e[0];
        }), 'min');
        maxPeaks = findPeaksForSet(indexed, 3, 3.5, (function(e) {
          return e[1];
        }), (function(e) {
          return e[0];
        }), 'max');
        chart = render(_.zip(timestamps, values));
        meanDurationMin = averageDistance(minPeaks);
        meanDurationMax = averageDistance(maxPeaks);
        console.log("Heartrate:", 60000 / ((meanDurationMin + meanDurationMax) / 2));
        for (_i = 0, _len = minPeaks.length; _i < _len; _i++) {
          peak = minPeaks[_i];
          chart.series[0].points[peak[0]].update({
            marker: {
              enabled: true,
              symbol: 'circle',
              fillColor: "#ff0000",
              lineColor: "#ff0000",
              radius: 7
            }
          });
        }
        _results = [];
        for (_j = 0, _len1 = maxPeaks.length; _j < _len1; _j++) {
          peak = maxPeaks[_j];
          _results.push(chart.series[0].points[peak[0]].update({
            marker: {
              enabled: true,
              symbol: 'circle',
              fillColor: "#00ff00",
              lineColor: "#00ff00",
              radius: 7
            }
          }));
        }
        return _results;
      };
      read = openAndReadFile('series.json', callback);
      return window.requestFileSystem(window.TEMPORARY, 1024 * 1024, read, fileError);
    });
    averageDistance = function(peaks) {
      var i, index, nextPeak, nextTimestamp, peak, sumDuration, timestamp, _i, _len;
      sumDuration = 0;
      for (i = _i = 0, _len = peaks.length; _i < _len; i = ++_i) {
        peak = peaks[i];
        index = peak[0];
        nextPeak = peaks[i + 1];
        if (!!nextPeak) {
          timestamp = timestamps[index];
          nextTimestamp = timestamps[nextPeak[0]];
          if (nextTimestamp) {
            sumDuration += nextTimestamp - timestamp;
          }
        }
      }
      return sumDuration / (peaks.length - 1);
    };
    return render = function(points) {
      var series;
      series = [
        {
          name: "Intensities",
          data: points
        }, {
          Â name: "Intensities (smooth)",
          data: smooth(points, 4, 5, (function(e) {
            return e[1];
          }), (function(s, e) {
            return [e[0], s];
          }))
        }
      ];
      return new Highcharts.Chart({
        chart: {
          renderTo: 'graph'
        },
        yAxis: {
          title: {
            text: 'Intensity'
          }
        },
        xAxis: {
          title: {
            text: 'Timestamp (ms)'
          }
        },
        plotOptions: {
          series: {
            marker: {
              enabled: false
            }
          }
        },
        series: series
      });
    };
  });

  smooth = function(set, runs, span, selector, builder) {
    var buffer, div, p, point, smoothData, sum, _i, _j, _len, _len1, _ref;
    if (runs == null) {
      runs = 1;
    }
    if (span == null) {
      span = 3;
    }
    _ref = [[], []], buffer = _ref[0], smoothData = _ref[1];
    for (_i = 0, _len = set.length; _i < _len; _i++) {
      point = set[_i];
      buffer.push(selector != null ? selector(point) : point);
      if (buffer.length > span) {
        buffer.splice(0, 1);
      }
      sum = 0;
      for (_j = 0, _len1 = buffer.length; _j < _len1; _j++) {
        p = buffer[_j];
        sum += p;
      }
      div = buffer.length < span ? buffer.length : span;
      smoothData.push(builder != null ? builder(sum / div, point) : sum / div);
    }
    if (runs > 1) {
      return smooth(smoothData, --runs, span, selector, builder);
    } else {
      return smoothData;
    }
  };

  findPeaksForSet = function(list, runs, span, compare, selector, method) {
    var comp, i, item, j, peaks, slice, sliceItem, threshold, _i, _j, _len, _len1, _step;
    if (runs == null) {
      runs = 1;
    }
    if (span == null) {
      span = 3;
    }
    if (method == null) {
      method = 'min';
    }
    peaks = [];
    for (i = _i = 0, _len = list.length, _step = span; _i < _len; i = _i += _step) {
      item = list[i];
      slice = list.slice(i, span + i);
      threshold = slice[0];
      comp = function(a, b) {
        if (method === 'min') {
          return a < b;
        } else {
          return a > b;
        }
      };
      for (j = _j = 0, _len1 = slice.length; _j < _len1; j = ++_j) {
        sliceItem = slice[j];
        if (compare != null) {
          if (comp(compare(sliceItem), compare(threshold))) {
            threshold = sliceItem;
          }
        } else {
          if (comp(sliceItem, threshold)) {
            threshold = sliceItem;
          }
        }
      }
      peaks.push(threshold);
    }
    if (runs > 1) {
      return findPeaksForSet(peaks, --runs, span, compare, selector, method);
    } else {
      return peaks;
    }
  };

  fileError = function(e) {
    return console.error((function() {
      switch (e.code) {
        case FileError.QUOTA_EXCEEDED_ERR:
          return 'QUOTA_EXCEEDED_ERR';
        case FileError.NOT_FOUND_ERR:
          return 'NOT_FOUND_ERR';
        case FileError.SECURITY_ERR:
          return 'SECURITY_ERR';
        case FileError.INVALID_MODIFICATION_ERR:
          return 'INVALID_MODIFICATION_ERR';
        case FileError.INVALID_STATE_ERR:
          return 'INVALID_STATE_ERR';
        default:
          return 'Unknown Error';
      }
    })());
  };

  openAndWriteFile = function(file, contents) {
    return function(fs) {
      return openFile(fs, file, (function(entry) {
        return writeFile(entry, contents);
      }), fileError);
    };
  };

  openAndReadFile = function(file, callback) {
    return function(fs) {
      return openFile(fs, file, (function(entry) {
        return readFile(entry, callback);
      }), fileError, false);
    };
  };

  readFile = function(file, callback) {
    var fileReader;
    fileReader = function(entry) {
      var reader;
      reader = new FileReader();
      reader.onloadend = function() {
        return callback(this.result);
      };
      return reader.readAsText(entry);
    };
    return file.file(fileReader, fileError);
  };

  writeFile = function(file, contents) {
    var fileWriter;
    fileWriter = function(writer) {
      var blob;
      writer.onwriteend = function() {
        return console.log('Write completed.');
      };
      writer.onerror = function(e) {
        return console.error("Write failed: " + (e.toString()));
      };
      blob = new Blob([contents], {
        type: 'text/plain'
      });
      return writer.write(blob);
    };
    return file.createWriter(fileWriter, fileError);
  };

  openFile = function(fs, file, callback, create) {
    if (create == null) {
      create = true;
    }
    return fs.root.getFile(file, {
      create: create
    }, callback, fileError);
  };

  $.fn.countdown = function(duration, callback) {
    var $el, count, interval, start;
    start = (new Date).getTime();
    interval = null;
    $el = this;
    count = function() {
      var diff, now;
      now = (new Date).getTime();
      diff = now - start;
      $el.text(Math.round((duration - diff) / 1000));
      if (diff >= duration) {
        if (callback != null) {
          callback();
        }
        return clearInterval(interval);
      }
    };
    return interval = setInterval(count, 50);
  };

}).call(this);
